import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../app/store';
import { fetchTopRatedWaves, fetchWaveInfo, saveWave, deleteWave } from './wavesForecastAPI';
import { IDataNodeType } from "../../utils/customUI/d3Tree/Globals/data/Interfaces/GOTElementInterfaces";
import { Wave, ChartPoint } from '../interfaces/wave';
import { unix } from 'moment';

export interface WavesForecastState {
  workTree: IDataNodeType;
  wavesInView: Wave [];
  tempWave: Wave;
  selectedWave: Wave;
  selectedPoint: ChartPoint;

  loadDataStatus: string;
  error: string;
}

const initialState: WavesForecastState = {
  //index: 'EURUSD',
  //timeFrame: '5min',
  workTree: undefined,
  wavesInView: [],
  tempWave: undefined,
  selectedWave: undefined,
  selectedPoint: undefined,
  loadDataStatus: '',
  error: ''
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const fetchTopRatedAsync = createAsyncThunk(
  'wavesForecast/fetchTopRated',
  async ( {index_, timeFrame_, token} : {index_: string, timeFrame_: any, token: string} ) => {    // - прямо новый класс определяем, поэтому при вызове нужно названия переменных не менять
    const response = await fetchTopRatedWaves(index_, timeFrame_, token);
    // The value we return becomes the `fulfilled` action payload  
    return response.data;
  }
);
export const fetchWaveInfoAsync = createAsyncThunk(
  'wavesForecast/fetchWaveInfoAsync',
  async ( {wave_id, token} : {wave_id: string, token: string} ) => {    // - прямо новый класс определяем, поэтому при вызове нужно названия переменных не менять
    const response = await fetchWaveInfo(wave_id, token);
    // The value we return becomes the `fulfilled` action payload  
    return response.data;
  }
);
export const saveWaveAsync = createAsyncThunk(
  'wavesForecast/saveWaveAsync',
  async ( {wave, token} : {wave: Wave, token: string} ) => {    // - прямо новый класс определяем, поэтому при вызове нужно названия переменных не менять
    const response = await saveWave(wave, token);
    // The value we return becomes the `fulfilled` action payload  
    return response;
  }
);
export const deleteWaveAsync = createAsyncThunk(
  'wavesForecast/deleteWaveAsync',
  async ( {wave, token} : {wave: Wave, token: string} ) => {    // - прямо новый класс определяем, поэтому при вызове нужно названия переменных не менять
    const response = await deleteWave(wave, token);
    // The value we return becomes the `fulfilled` action payload  
    return response;
  }
);

export const wavesForecastSlice = createSlice({
  name: 'wavesForecast',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // Use the PayloadAction type to declare the contents of `action.payload`
    setTempWave: (state, action: PayloadAction<Wave>) => {
      state.tempWave = action.payload;
    },
    setWaveToKeepInViewList: (state, action: PayloadAction<Wave>) => {
      state.wavesInView.splice(0, 0, action.payload);
    },
    setWaveToRemoveFromViewList: (state, action: PayloadAction<string>) => {     
      if(state.selectedWave!=undefined && state.selectedWave.id == action.payload)
        state.selectedWave = undefined;
      //state.wavesInView.splice(action.payload, 1);      
      var wavesIV: Wave [] = [...state.wavesInView]; 
      for(var i = 0; i < wavesIV.length; i++)   
      if(wavesIV[i].id == action.payload) {
        wavesIV.splice(i, 1);
        break;
      }  
      state.wavesInView = wavesIV;
    },
    setSelectedWave: (state, action: PayloadAction<Wave>) => {
      state.selectedWave = action.payload;
    },
    setSelectedPoint: (state, action: PayloadAction<ChartPoint>) => { 
      state.selectedPoint = action.payload;
    },
    setError: (state, action: PayloadAction<string>) => {
      state.error = action.payload;
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere, 
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchTopRatedAsync.pending, (state) => {
        state.loadDataStatus = 'loading';
      })
      .addCase(fetchTopRatedAsync.fulfilled, (state, action) => {
        state.loadDataStatus = 'complit';
        state.workTree = action.payload;
      })
      .addCase(fetchTopRatedAsync.rejected, (state) => {
        state.loadDataStatus = 'failed';
      })
      
      .addCase(fetchWaveInfoAsync.pending, (state) => {
        state.loadDataStatus = 'loading';
      })
      .addCase(fetchWaveInfoAsync.fulfilled, (state, action) => {
        state.loadDataStatus = 'complit';
        state.tempWave = action.payload;
        state.selectedWave = action.payload;
      })
      .addCase(fetchWaveInfoAsync.rejected, (state) => {
        state.loadDataStatus = 'failed';
      })

      .addCase(saveWaveAsync.pending, (state) => {
        state.loadDataStatus = 'loading';
      })
      .addCase(saveWaveAsync.fulfilled, (state, action) => {
        state.loadDataStatus = 'complit';
        state.selectedWave = action.payload.data;
        
        var wavesIV: Wave [] = [...state.wavesInView]; // - because impossible to call 'updateSelectedWave' from here
        for (var i = 0; i < wavesIV.length; i++)   
        if( wavesIV[i].id == action.payload.prevId ) {
          wavesIV.splice(i, 1);
          wavesIV.splice(0, 0, action.payload.data);          
          break;
        }  
        state.wavesInView = wavesIV;
      })
      .addCase(saveWaveAsync.rejected, (state, action) => {
        state.loadDataStatus = 'failed';
        state.error = action.error.message;
      })
      
      .addCase(deleteWaveAsync.pending, (state) => {
        state.loadDataStatus = 'loading';
      })
      .addCase(deleteWaveAsync.fulfilled, (state, action) => {
        state.loadDataStatus = 'complit';
        state.selectedWave = undefined;
        if(state.tempWave.id == action.payload.removeId)
          state.tempWave = undefined;
        else {
          var wavesIV: Wave [] = [...state.wavesInView]; // - because impossible to call 'updateSelectedWave' from here
          for (var i = 0; i < wavesIV.length; i++)   
          if( wavesIV[i].id == action.payload.removeId ) {
            wavesIV.splice(i, 1);
            break;
          }  
          state.wavesInView = wavesIV;          
        }
      })
      .addCase(deleteWaveAsync.rejected, (state, action) => {
        state.loadDataStatus = 'failed';
        state.error = action.error.message;
      });      
  }
});

export const { setTempWave, setSelectedPoint, setSelectedWave, setWaveToKeepInViewList, setWaveToRemoveFromViewList, setError } = wavesForecastSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const getWavesInView = (state: RootState) => state.wavesForecast.wavesInView;
export const getWorkTree = (state: RootState) => state.wavesForecast.workTree;
export const getTempWave = (state: RootState) => state.wavesForecast.tempWave;
export const getSelectedWave = (state: RootState) => state.wavesForecast.selectedWave;
export const getSelectedWavePoints  = (state: RootState) => {
  var typedData = undefined;
  var wave = state.wavesForecast.selectedWave;
    if( undefined!=state.wavesForecast.selectedWave &&
        undefined!=state.wavesForecast.selectedWave.points ) {
      typedData = [];
      state.wavesForecast.selectedWave.points.forEach(function(item, i, arr) {
        typedData.push({ x: new Date(item.x), y: item.y, id: item.id });
      });
    }
  return typedData; 
}
export const getSelectedPoint = (state: RootState) => state.wavesForecast.selectedPoint;
export const getError  = (state: RootState) => state.wavesForecast.error;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
export const updateSelectedWave =
  (wave: Wave) : AppThunk =>
  (dispatch, getState) => {        
    // - update in source
    const wavesInView = getWavesInView(getState());
    const tempWave = getTempWave(getState());
    var wavesIV: Wave [] = [...wavesInView];    
    
    if(tempWave!=undefined && tempWave.id==wave.id) {
      dispatch(setWaveToKeepInViewList(wave));
      dispatch(setTempWave(undefined));
    }
    else {
      dispatch(setWaveToRemoveFromViewList(wave.id));
      dispatch(setWaveToKeepInViewList(wave));
    }
    dispatch(setSelectedWave(wave));  
  };

export const selectWave =
  (wave_id: string, token: string) : AppThunk =>
  (dispatch, getState) => {
    const wavesInView = getWavesInView(getState())
    const tempWave = getTempWave(getState())
    
    // - ищем - в открытых вкладках 
    var waveInView: Wave = undefined;    
    wavesInView.forEach( (w) => {
      if( w.id==wave_id )  
        waveInView = w;
    } );
    if(tempWave!=undefined && tempWave.id==wave_id)      
      waveInView = tempWave;
    
    if(waveInView!==undefined) 
      dispatch(setSelectedWave(waveInView));  // - выделяем в списке (ставим на временное место) и подсвечиваем 
    else  
      dispatch(fetchWaveInfoAsync( {wave_id, token} ));
  };  

  export const addAlternativeVariant =
  ( ) : AppThunk =>
  (dispatch, getState) => {
    const baseWave = getSelectedWave(getState());
    const workTree = getWorkTree(getState());

    if( baseWave!=undefined ) {  
      var newWave: Wave =
        { id: ''+Date.now(),
          type: undefined, 
          scale: undefined,
          points : [],
          entetyState: 'New',
          headerWave_id: getHeaderWaveId(baseWave.id, workTree) 
        }; 
        newWave.points.splice(1, 0, baseWave.points[0]);

        dispatch(setWaveToKeepInViewList(newWave));
        dispatch(updateSelectedWave(newWave)); 
    } 
    else  
      dispatch(setError('Base wave not found'));
  };
  
  export const addSubwaveVariant =
  ( ) : AppThunk =>
  (dispatch, getState) => {
    const baseWave = getSelectedWave(getState());

    if( baseWave!=undefined ) {  
      var newWave: Wave =
        { id: ''+Date.now(),
          type: undefined, 
          scale: undefined,
          points : [],
          entetyState: 'New',
          headerWave_id: baseWave.id 
        }; 
        newWave.points.splice(1, 0, baseWave.points[baseWave.points.length-1]); // - by default put in last wave

        dispatch(setWaveToKeepInViewList(newWave));
        dispatch(updateSelectedWave(newWave)); 
    } 
    else  
      dispatch(setError('Base wave not found'));
  };

  const getHeaderWaveId = (current_id: string, root: IDataNodeType) => {
    for (var i = 0; i < root.children.length; i++) {   
      if( root.children[i].id == current_id ) 
        return root.id;
      else {
        var headerWave_id = getHeaderWaveId(current_id, root.children[i]);
        if(headerWave_id!=undefined)
          return headerWave_id;
      } 
    }  
    return undefined;
  }

export default wavesForecastSlice.reducer;
