import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit';
import { RootState, AppThunk } from '../../app/store';
import { fetchChartData } from './chartMarkupAPI';
import { ChartPoint, ChartBreak } from '../interfaces/wave';

export interface ChartMarkupState {
  index: string;
  timeFrame: 'week' | 'day' | '60min' | '30min' | '15min' | '5min' | '1min';
  data: ChartPoint [];
  breaks: ChartBreak[];
  loadDataStatus: string;
  error: string;
}

const initialState: ChartMarkupState = {
  index: 'EURUSD',
  timeFrame: '5min',
  data: [ ],
  breaks: [ ],
  loadDataStatus: '',
  error: ''
};

// The function below is called a thunk and allows us to perform async logic. It
// can be dispatched like a regular action: `dispatch(incrementAsync(10))`. This
// will call the thunk with the `dispatch` function as the first argument. Async
// code can then be executed and other actions can be dispatched. Thunks are
// typically used to make async requests.
export const fetchChartDataAsync = createAsyncThunk(
  'chartMarkup/fetchData',
  async ( {index_, timeFrame_, token} : {index_: string, timeFrame_: any, token: string} ) => {    // - прямо новый класс определяем, поэтому при вызове нужно названия переменных не менять
    const response = await fetchChartData(index_, timeFrame_, token);
    // The value we return becomes the `fulfilled` action payload  
    return response;
  }
);

export const chartMarkupSlice = createSlice({
  name: 'chartMarkup',
  initialState,
  // The `reducers` field lets us define reducers and generate associated actions
  reducers: {
    // Use the PayloadAction type to declare the contents of `action.payload`
    setIndex: (state, action: PayloadAction<string>) => {
      state.index = action.payload;
    },
    setTimeFrame: (state, action: PayloadAction<any>) => {
      state.timeFrame = action.payload;
    },
    setError: (state, action: PayloadAction<string>) => {
      state.error = action.payload;
    }
  },
  // The `extraReducers` field lets the slice handle actions defined elsewhere,
  // including actions generated by createAsyncThunk or in other slices.
  extraReducers: (builder) => {
    builder
      .addCase(fetchChartDataAsync.pending, (state) => {
        state.loadDataStatus = 'loading';
      })
      .addCase(fetchChartDataAsync.fulfilled, (state, action) => {
        state.loadDataStatus = 'complit';        
        state.data = action.payload.data;
        state.breaks = action.payload.breaks;
      })
      .addCase(fetchChartDataAsync.rejected, (state, action) => {
        state.loadDataStatus = 'failed';
        state.error = action.error.message;
      });
  }
});

export const { setIndex, setTimeFrame, setError } = chartMarkupSlice.actions;

// The function below is called a selector and allows us to select a value from
// the state. Selectors can also be defined inline where they're used instead of
// in the slice file. For example: `useSelector((state: RootState) => state.counter.value)`
export const getIndex  = (state: RootState) => state.chartMarkup.index;
export const getData  = (state: RootState) => {
  var typedData = [];
    state.chartMarkup.data.forEach(function(item, i, arr) {
      typedData.push({ x: new Date(item.x), y: item.y, id: item.id });
  });
  return typedData; 
}
export const getBreaks  = (state: RootState) => {
  var typedData = [];
  state.chartMarkup.breaks.forEach(function(item, i, arr) {
      typedData.push({ startValue: new Date(item.startValue), endValue: new Date(item.endValue) });
  });
  return typedData;
}
export const getTimeFrame  = (state: RootState) => state.chartMarkup.timeFrame;
export const getLoadDataStatus  = (state: RootState) => state.chartMarkup.loadDataStatus;
export const getError  = (state: RootState) => state.chartMarkup.error;

// We can also write thunks by hand, which may contain both sync and async logic.
// Here's an example of conditionally dispatching actions based on current state.
/*export const incrementIfOdd =
  (amount: number): AppThunk =>
  (dispatch, getState) => {
    const currentValue = selectCount(getState());
    if (currentValue % 2 === 1) {
      dispatch(incrementByAmount(amount));
    }
  };*/

export default chartMarkupSlice.reducer;
